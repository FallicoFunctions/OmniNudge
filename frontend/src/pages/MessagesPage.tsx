import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { useSearchParams } from 'react-router-dom';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { messagesService } from '../services/messagesService';
import { mediaService } from '../services/mediaService';
import { useAuth } from '../contexts/AuthContext';
import { useMessagingContext } from '../contexts/MessagingContext';
import type { Conversation, Message, SendMessageRequest } from '../types/messages';
import { API_BASE_URL } from '../lib/api';
import { decryptMessage, encryptFile, decryptFile } from '../utils/encryption';
import { getOwnKeys, getUserPublicKey } from '../services/keyManagementService';
import { encryptionService } from '../services/encryptionService';

const MAX_UPLOAD_SIZE = 25 * 1024 * 1024; // 25MB

function inferMessageTypeFromFile(file: File): Message['message_type'] {
  if (file.type.startsWith('video/')) {
    return 'video';
  }
  if (file.type.startsWith('image/')) {
    return 'image';
  }
  if (file.type.startsWith('audio/')) {
    return 'audio';
  }
  return 'file';
}

interface MessageMediaPreviewProps {
  message: Message;
}

const API_ORIGIN = new URL(API_BASE_URL).origin;

function isAutoGeneratedMediaCaption(message: Message) {
  if (!message.media_url || !message.encrypted_content) return false;
  const normalized = message.encrypted_content.replace(/^ðŸ“Ž\s*/, '').trim().toLowerCase();
  return normalized === 'media';
}

function inferMessageTypeFromMessage(message: Message): Message['message_type'] {
  if (message.message_type && message.message_type !== 'text') {
    return message.message_type;
  }

  const mime = message.media_type ?? '';
  if (mime.startsWith('video/')) return 'video';
  if (mime.startsWith('image/')) return 'image';
  if (mime.startsWith('audio/')) return 'audio';
  return 'file';
}

/**
 * Hook to decrypt a message's encrypted_content
 * Returns the decrypted content or the original content if decryption fails
 */
function useDecryptedContent(encryptedContent: string | undefined): string {
  const [decryptedContent, setDecryptedContent] = useState<string>('');

  useEffect(() => {
    if (!encryptedContent) {
      setDecryptedContent('');
      return;
    }

    const attemptDecryption = async () => {
      try {
        const keys = await getOwnKeys();
        if (!keys) {
          // No keys available, return plaintext
          setDecryptedContent(encryptedContent);
          return;
        }

        const decrypted = await decryptMessage(encryptedContent, keys.privateKey);
        setDecryptedContent(decrypted);
      } catch (error) {
        // Decryption failed, content might be plaintext
        console.warn('Failed to decrypt message, displaying as plaintext:', error);
        setDecryptedContent(encryptedContent);
      }
    };

    attemptDecryption();
  }, [encryptedContent]);

  return decryptedContent;
}

/**
 * Component to display decrypted message content
 */
function DecryptedMessageContent({ content, className }: { content: string | undefined; className?: string }) {
  const decryptedContent = useDecryptedContent(content);

  if (!decryptedContent) return null;

  return <p className={className}>{decryptedContent}</p>;
}

/**
 * Hook to decrypt media files
 * Returns a blob URL to the decrypted media, or the original URL if not encrypted
 */
function useDecryptedMedia(message: Message): string {
  const [mediaSrc, setMediaSrc] = useState<string>('');

  useEffect(() => {
    const decryptMedia = async () => {
      // Build the media URL
      const originalUrl = message.media_url
        ? message.media_url.startsWith('http')
          ? message.media_url
          : `${API_ORIGIN}${message.media_url.startsWith('/') ? '' : '/'}${message.media_url}`
        : '';

      // If no encryption metadata, return original URL
      if (!message.media_encryption_key || !message.media_encryption_iv) {
        setMediaSrc(originalUrl);
        return;
      }

      try {
        // Get own private key
        const keys = await getOwnKeys();
        if (!keys) {
          console.warn('No encryption keys available, displaying encrypted file as-is');
          setMediaSrc(originalUrl);
          return;
        }

        // Fetch the encrypted file
        const response = await fetch(originalUrl);
        const encryptedData = await response.arrayBuffer();

        // Decrypt the file
        const decryptedBlob = await decryptFile(
          {
            encryptedData,
            encryptedKey: message.media_encryption_key,
            iv: message.media_encryption_iv,
            originalName: message.media_url?.split('/').pop() ?? 'attachment',
            mimeType: message.media_type ?? 'application/octet-stream',
          },
          keys.privateKey
        );

        // Create blob URL
        const blobUrl = URL.createObjectURL(decryptedBlob);
        setMediaSrc(blobUrl);

        // Cleanup blob URL on unmount
        return () => {
          URL.revokeObjectURL(blobUrl);
        };
      } catch (error) {
        console.error('Failed to decrypt media file:', error);
        // Fallback to original URL
        setMediaSrc(originalUrl);
      }
    };

    decryptMedia();
  }, [message.media_url, message.media_encryption_key, message.media_encryption_iv, message.media_type]);

  return mediaSrc;
}

const MessageMediaPreview = ({ message }: MessageMediaPreviewProps) => {
  const mediaSrc = useDecryptedMedia(message);
  const filename = message.media_url?.split('/').pop() ?? 'attachment';

  const resolvedType = inferMessageTypeFromMessage(message);

  if (resolvedType === 'image') {
    return (
      <div className="mb-2">
        <img
          src={mediaSrc}
          alt="Shared media"
          className="max-w-full rounded cursor-pointer"
          onClick={() => window.open(mediaSrc, '_blank')}
        />
      </div>
    );
  }

  if (resolvedType === 'video') {
    return (
      <div className="mb-2">
        <video src={mediaSrc} controls className="max-w-full rounded" />
      </div>
    );
  }

  if (resolvedType === 'audio') {
    return (
      <div className="mb-2">
        <audio controls className="w-full">
          <source src={mediaSrc} type={message.media_type ?? 'audio/mpeg'} />
          Your browser does not support the audio element.
        </audio>
      </div>
    );
  }

  return (
    <div className="mb-2">
      <a
        href={mediaSrc}
        target="_blank"
        rel="noopener noreferrer"
        className="inline-flex items-center gap-1 text-sm underline hover:text-[var(--color-primary-light)]"
        download={filename}
      >
        {filename}
      </a>
    </div>
  );
};

export default function MessagesPage() {
  const { user } = useAuth();
  const { setActiveConversationId } = useMessagingContext();
  const [selectedConversationId, setSelectedConversationId] = useState<number | null>(null);
  const [messageText, setMessageText] = useState('');
  const [newChatUsername, setNewChatUsername] = useState('');
  const [isCreatingChat, setIsCreatingChat] = useState(false);
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [uploadingMedia, setUploadingMedia] = useState(false);
  const queryClient = useQueryClient();
  const [searchParams] = useSearchParams();
  const toUsernameParam = searchParams.get('to');
  const fileInputRef = useRef<HTMLInputElement>(null);

  const { data: conversations, isLoading: loadingConversations } = useQuery({
    queryKey: ['conversations'],
    queryFn: () => messagesService.getConversations(),
  });

  const { data: messages, isLoading: loadingMessages } = useQuery({
    queryKey: ['messages', selectedConversationId],
    queryFn: () => messagesService.getMessages(selectedConversationId!),
    enabled: !!selectedConversationId,
    refetchOnWindowFocus: false,
  });

  const uploadMediaMutation = useMutation({
    mutationFn: (file: File) => mediaService.uploadMedia(file),
  });

  const sendMessageMutation = useMutation({
    mutationFn: (data: SendMessageRequest) => messagesService.sendMessage(data),
    onSuccess: (message, variables) => {
      queryClient.invalidateQueries({ queryKey: ['messages', message.conversation_id] });
      queryClient.setQueryData<Conversation[] | undefined>(['conversations'], (prev) => {
        if (!prev) return prev;
        return prev.map((conv) =>
          conv.id === message.conversation_id
            ? {
                ...conv,
                unread_count: 0,
                latest_message: message,
              }
            : conv
        );
      });
      setMessageText('');
      setSelectedFile(null);
      if (!variables.conversation_id && variables.recipient_username) {
        setSelectedConversationId(message.conversation_id);
        setIsCreatingChat(false);
        setNewChatUsername('');
      }
    },
  });

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      if (file.size > MAX_UPLOAD_SIZE) {
        alert('File too large. Maximum size is 25MB.');
        return;
      }
      setSelectedFile(file);
    }
  };

  const handleSendMessage = async (e: React.FormEvent) => {
    e.preventDefault();
    const trimmedMessage = messageText.trim();
    if (!trimmedMessage && !selectedFile) return;

    try {
      let mediaFileId: number | undefined;
      let mediaUrl: string | undefined;
      let mediaMimeType: string | undefined;
      let mediaSize: number | undefined;
      let messageType: Message['message_type'] = 'text';
      let mediaEncryptionKey: string | undefined;
      let mediaEncryptionIv: string | undefined;

      // Upload media first if selected
      if (selectedFile) {
        setUploadingMedia(true);

        // Get recipient's ID to fetch their public key
        let recipientId: number | undefined;
        if (isCreatingChat) {
          // For new chats, we need to fetch the user by username
          const recipient = newChatUsername.trim();
          if (recipient) {
            try {
              const user = await fetch(`${API_BASE_URL}/users/${recipient}`, {
                headers: {
                  Authorization: `Bearer ${localStorage.getItem('auth_token')}`,
                },
              }).then((res) => res.json());
              recipientId = user.id;
            } catch (error) {
              console.warn('Failed to fetch recipient user:', error);
            }
          }
        } else if (selectedConversationId) {
          // For existing conversations, get recipient from conversation
          recipientId = selectedConversation?.other_user?.id;
        }

        // Encrypt the file if we have a recipient ID
        let fileToUpload = selectedFile;
        if (recipientId) {
          try {
            // Fetch recipient's public key
            const publicKeys = await encryptionService.getPublicKeys([recipientId]);
            const recipientPublicKeyBase64 = publicKeys[recipientId];

            if (recipientPublicKeyBase64) {
              // Import recipient's public key
              const recipientPublicKey = await getUserPublicKey(recipientId, recipientPublicKeyBase64);

              if (recipientPublicKey) {
                // Encrypt the file
                const encryptedFile = await encryptFile(selectedFile, recipientPublicKey);

                // Store encryption metadata
                mediaEncryptionKey = encryptedFile.encryptedKey;
                mediaEncryptionIv = encryptedFile.iv;

                // Create a new File from encrypted data
                const encryptedBlob = new Blob([encryptedFile.encryptedData], {
                  type: 'application/octet-stream',
                });
                fileToUpload = new File([encryptedBlob], selectedFile.name, {
                  type: 'application/octet-stream',
                });
              } else {
                console.warn('Failed to import recipient public key, uploading unencrypted');
              }
            } else {
              console.warn('Recipient has no public key, uploading unencrypted');
            }
          } catch (error) {
            console.error('File encryption failed, uploading unencrypted:', error);
          }
        }

        // Upload the file (encrypted or original)
        const uploadedMedia = await uploadMediaMutation.mutateAsync(fileToUpload);
        mediaFileId = uploadedMedia.id;
        if (uploadedMedia.storage_url) {
          if (uploadedMedia.storage_url.startsWith('http')) {
            const urlObj = new URL(uploadedMedia.storage_url);
            mediaUrl = urlObj.pathname;
          } else {
            mediaUrl = uploadedMedia.storage_url.startsWith('/')
              ? uploadedMedia.storage_url
              : `/${uploadedMedia.storage_url}`;
          }
        } else if (uploadedMedia.storage_path) {
          const normalizedPath = uploadedMedia.storage_path.replace(/^\/?uploads\/?/, '');
          mediaUrl = `/uploads/${normalizedPath}`;
        }
        mediaMimeType = uploadedMedia.file_type;
        mediaSize = uploadedMedia.file_size;
        messageType = inferMessageTypeFromFile(selectedFile);
        setUploadingMedia(false);
      }

      if (isCreatingChat) {
        const recipient = newChatUsername.trim();
        if (!recipient) return;
        sendMessageMutation.mutate({
          recipient_username: recipient,
          content: trimmedMessage || undefined,
          media_file_id: mediaFileId,
          media_url: mediaUrl,
          media_type: mediaMimeType,
          media_size: mediaSize,
          message_type: messageType,
          media_encryption_key: mediaEncryptionKey,
          media_encryption_iv: mediaEncryptionIv,
        });
        return;
      }

      if (selectedConversationId) {
        sendMessageMutation.mutate({
          conversation_id: selectedConversationId,
          content: trimmedMessage || undefined,
          media_file_id: mediaFileId,
          media_url: mediaUrl,
          media_type: mediaMimeType,
          media_size: mediaSize,
          message_type: messageType,
          media_encryption_key: mediaEncryptionKey,
          media_encryption_iv: mediaEncryptionIv,
        });
      }
    } catch (error) {
      setUploadingMedia(false);
      console.error('Failed to send message:', error);
      alert('Failed to upload media. Please try again.');
    }
  };

  const selectedConversation = conversations?.find((c) => c.id === selectedConversationId);
  const orderedMessages = useMemo(() => (messages ? [...messages].reverse() : []), [messages]);
  const messagesContainerRef = useRef<HTMLDivElement | null>(null);
  const scrollToLatestMessage = useCallback(() => {
    const container = messagesContainerRef.current;
    if (container) {
      container.scrollTop = container.scrollHeight;
    }
  }, []);

  const markConversationAsRead = useCallback(
    async (conversationId: number) => {
      try {
        await messagesService.markAsRead(conversationId);
        queryClient.setQueryData<Conversation[] | undefined>(['conversations'], (prev) => {
          if (!prev) return prev;
          return prev.map((conv) =>
            conv.id === conversationId ? { ...conv, unread_count: 0 } : conv
          );
        });
        queryClient.invalidateQueries({ queryKey: ['conversations'] });
      } catch (error) {
        console.error('Failed to mark conversation as read', error);
      }
    },
    [queryClient]
  );

  // Sync selected conversation with global messaging context
  useEffect(() => {
    setActiveConversationId(selectedConversationId);
    return () => {
      setActiveConversationId(null);
    };
  }, [selectedConversationId, setActiveConversationId]);

  useEffect(() => {
    if (selectedConversationId && !isCreatingChat) {
      markConversationAsRead(selectedConversationId);
    }
  }, [selectedConversationId, isCreatingChat, markConversationAsRead]);

  useEffect(() => {
    if (toUsernameParam) {
      setIsCreatingChat(true);
      setSelectedConversationId(null);
      setNewChatUsername(toUsernameParam);
    }
  }, [toUsernameParam]);

  useEffect(() => {
    if (!selectedConversationId || isCreatingChat || loadingMessages) return;
    scrollToLatestMessage();
  }, [selectedConversationId, isCreatingChat, loadingMessages, scrollToLatestMessage, messages]);

  return (
    <div className="mx-auto flex h-[calc(100vh-8rem)] max-w-6xl gap-4 px-4 py-8">
      {/* Conversations List */}
      <div className="w-80 flex-shrink-0 overflow-hidden rounded-lg border border-[var(--color-border)] bg-[var(--color-surface)]">
        <div className="border-b border-[var(--color-border)] p-4">
          <div className="flex items-center justify-between">
            <h2 className="text-lg font-semibold text-[var(--color-text-primary)]">Messages</h2>
            <button
              onClick={() => {
                setIsCreatingChat(true);
                setSelectedConversationId(null);
                setNewChatUsername('');
                setMessageText('');
                setSelectedFile(null);
              }}
              className="rounded-md bg-[var(--color-primary)] px-3 py-1 text-sm font-semibold text-white hover:bg-[var(--color-primary-dark)]"
            >
              New Chat
            </button>
          </div>
        </div>

        <div className="overflow-y-auto" style={{ height: 'calc(100% - 65px)' }}>
          {loadingConversations && (
            <div className="p-4 text-center text-sm text-[var(--color-text-secondary)]">
              Loading...
            </div>
          )}

          {conversations?.map((conversation) => (
            <button
              key={conversation.id}
              onClick={() => {
                setSelectedConversationId(conversation.id);
                setIsCreatingChat(false);
                setNewChatUsername('');
                setSelectedFile(null);
              }}
              className={`w-full border-b border-[var(--color-border)] p-4 text-left transition-colors ${
                selectedConversationId === conversation.id
                  ? 'bg-[var(--color-surface-elevated)]'
                  : 'hover:bg-[var(--color-surface-elevated)]'
              }`}
            >
              <div className="flex items-center justify-between">
                <span className="font-medium text-[var(--color-text-primary)]">
                  {conversation.other_user?.username || 'Unknown'}
                </span>
                {conversation.unread_count > 0 && conversation.id !== selectedConversationId && (
                  <span className="rounded-full bg-[var(--color-primary)] px-2 py-0.5 text-xs text-white">
                    {conversation.unread_count}
                  </span>
                )}
              </div>
              {conversation.latest_message &&
                conversation.latest_message.encrypted_content &&
                !isAutoGeneratedMediaCaption(conversation.latest_message) && (
                  <DecryptedMessageContent
                    content={conversation.latest_message.encrypted_content}
                    className="mt-1 truncate text-sm text-[var(--color-text-secondary)]"
                  />
                )}
            </button>
          ))}

          {conversations?.length === 0 && (
            <div className="p-4 text-center text-sm text-[var(--color-text-secondary)]">
              No conversations yet. Start a new chat!
            </div>
          )}
        </div>
      </div>

      {/* Chat Area */}
      <div className="flex flex-1 flex-col overflow-hidden rounded-lg border border-[var(--color-border)] bg-[var(--color-surface)]">
        {selectedConversationId || isCreatingChat ? (
          <>
            {/* Chat Header */}
            <div className="border-b border-[var(--color-border)] p-4">
              <h3 className="font-semibold text-[var(--color-text-primary)]">
                {isCreatingChat
                  ? 'New Chat'
                  : selectedConversation?.other_user?.username || 'Unknown'}
              </h3>
            </div>

            {/* Messages */}
            <div ref={messagesContainerRef} className="flex-1 overflow-y-auto p-4">
              {isCreatingChat ? (
                <div className="text-center text-sm text-[var(--color-text-secondary)]">
                  Enter a username and message to start a conversation
                </div>
              ) : loadingMessages ? (
                <div className="text-center text-sm text-[var(--color-text-secondary)]">
                  Loading messages...
                </div>
              ) : (
                <div className="space-y-3">
                  {orderedMessages.map((message) => (
                    <div
                      key={message.id}
                      className={`flex ${message.sender_id === user?.id ? 'justify-end' : 'justify-start'}`}
                    >
                      <div
                        className={`max-w-md rounded-lg px-4 py-2 ${
                          message.sender_id === user?.id
                            ? 'bg-[var(--color-primary)] text-white'
                            : 'bg-[var(--color-surface-elevated)] text-[var(--color-text-primary)]'
                        }`}
                      >
                        {message.media_url && (
                          <MessageMediaPreview message={message} />
                        )}
                        {message.encrypted_content && !isAutoGeneratedMediaCaption(message) && (
                          <DecryptedMessageContent content={message.encrypted_content} className="text-sm" />
                        )}
                        <span
                          className={`mt-1 block text-xs ${
                            message.sender_id === user?.id
                              ? 'text-white/70'
                              : 'text-[var(--color-text-muted)]'
                          }`}
                        >
                          {new Date(message.sent_at).toLocaleTimeString()}
                        </span>
                      </div>
                    </div>
                  ))}

                  {orderedMessages.length === 0 && (
                    <div className="text-center text-sm text-[var(--color-text-secondary)]">
                      No messages yet. Send the first message!
                    </div>
                  )}
                </div>
              )}
            </div>

            {/* Message Input */}
            <div className="border-t border-[var(--color-border)] p-4">
              {isCreatingChat && (
                <input
                  type="text"
                  value={newChatUsername}
                  onChange={(e) => setNewChatUsername(e.target.value)}
                  placeholder="Enter username..."
                  className="mb-2 block w-full rounded-md border border-[var(--color-border)] bg-[var(--color-surface-elevated)] px-3 py-2 text-sm text-[var(--color-text-primary)] placeholder-[var(--color-text-muted)] focus:border-[var(--color-primary)] focus:outline-none focus:ring-1 focus:ring-[var(--color-primary)]"
                />
              )}

              {selectedFile && (
                <div className="mb-2 flex items-center gap-2 rounded-md bg-[var(--color-surface-elevated)] p-2">
                  <span className="text-sm text-[var(--color-text-secondary)]">
                    {selectedFile.name}
                  </span>
                  <button
                    onClick={() => setSelectedFile(null)}
                    className="ml-auto text-sm text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)]"
                  >
                    âœ•
                  </button>
                </div>
              )}

              <form onSubmit={handleSendMessage} className="flex gap-2">
                <input
                  type="file"
                  ref={fileInputRef}
                  onChange={handleFileSelect}
                  className="hidden"
                />
                <button
                  type="button"
                  onClick={() => fileInputRef.current?.click()}
                  className="rounded-md border border-[var(--color-border)] bg-[var(--color-surface-elevated)] px-3 py-2 text-sm text-[var(--color-text-primary)] hover:bg-[var(--color-surface)]"
                  title="Attach file"
                >
                  ðŸ“Ž
                </button>
                <input
                  type="text"
                  value={messageText}
                  onChange={(e) => setMessageText(e.target.value)}
                  placeholder="Type a message..."
                  className="flex-1 rounded-md border border-[var(--color-border)] bg-[var(--color-surface-elevated)] px-3 py-2 text-sm text-[var(--color-text-primary)] placeholder-[var(--color-text-muted)] focus:border-[var(--color-primary)] focus:outline-none focus:ring-1 focus:ring-[var(--color-primary)]"
                />
                <button
                  type="submit"
                  disabled={
                    sendMessageMutation.isPending || uploadingMedia || (isCreatingChat && !newChatUsername.trim())
                  }
                  className="rounded-md bg-[var(--color-primary)] px-4 py-2 text-sm font-semibold text-white hover:bg-[var(--color-primary-dark)] disabled:opacity-50"
                >
                  {uploadingMedia ? 'Uploading...' : 'Send'}
                </button>
              </form>
            </div>
          </>
        ) : (
          <div className="flex flex-1 items-center justify-center text-[var(--color-text-secondary)]">
            Select a conversation or start a new chat
          </div>
        )}
      </div>
    </div>
  );
}
