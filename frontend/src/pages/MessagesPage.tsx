import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { useSearchParams } from 'react-router-dom';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { messagesService } from '../services/messagesService';
import { mediaService } from '../services/mediaService';
import { useAuth } from '../contexts/AuthContext';
import { useMessagingContext } from '../contexts/MessagingContext';
import type { Conversation, Message, SendMessageRequest } from '../types/messages';
import { API_BASE_URL } from '../lib/api';

const MAX_UPLOAD_SIZE = 25 * 1024 * 1024; // 25MB

function inferMessageTypeFromFile(file: File): Message['message_type'] {
  if (file.type.startsWith('video/')) {
    return 'video';
  }
  if (file.type.startsWith('image/')) {
    return 'image';
  }
  if (file.type.startsWith('audio/')) {
    return 'audio';
  }
  return 'file';
}

interface MessageMediaPreviewProps {
  message: Message;
}

const API_ORIGIN = new URL(API_BASE_URL).origin;

function isAutoGeneratedMediaCaption(message: Message) {
  if (!message.media_url || !message.encrypted_content) return false;
  const normalized = message.encrypted_content.replace(/^ðŸ“Ž\s*/, '').trim().toLowerCase();
  return normalized === 'media';
}

function inferMessageTypeFromMessage(message: Message): Message['message_type'] {
  if (message.message_type && message.message_type !== 'text') {
    return message.message_type;
  }

  const mime = message.media_type ?? '';
  if (mime.startsWith('video/')) return 'video';
  if (mime.startsWith('image/')) return 'image';
  if (mime.startsWith('audio/')) return 'audio';
  return 'file';
}

const MessageMediaPreview = ({ message }: MessageMediaPreviewProps) => {
  const mediaSrc = message.media_url
    ? message.media_url.startsWith('http')
      ? message.media_url
      : `${API_ORIGIN}${message.media_url.startsWith('/') ? '' : '/'}${message.media_url}`
    : '';
  const filename = message.media_url?.split('/').pop() ?? 'attachment';

  const resolvedType = inferMessageTypeFromMessage(message);

  if (resolvedType === 'image') {
    return (
      <div className="mb-2">
        <img
          src={mediaSrc}
          alt="Shared media"
          className="max-w-full rounded cursor-pointer"
          onClick={() => window.open(mediaSrc, '_blank')}
        />
      </div>
    );
  }

  if (resolvedType === 'video') {
    return (
      <div className="mb-2">
        <video src={mediaSrc} controls className="max-w-full rounded" />
      </div>
    );
  }

  if (resolvedType === 'audio') {
    return (
      <div className="mb-2">
        <audio controls className="w-full">
          <source src={mediaSrc} type={message.media_type ?? 'audio/mpeg'} />
          Your browser does not support the audio element.
        </audio>
      </div>
    );
  }

  return (
    <div className="mb-2">
      <a
        href={mediaSrc}
        target="_blank"
        rel="noopener noreferrer"
        className="inline-flex items-center gap-1 text-sm underline hover:text-[var(--color-primary-light)]"
        download={filename}
      >
        {filename}
      </a>
    </div>
  );
};

export default function MessagesPage() {
  const { user } = useAuth();
  const { setActiveConversationId } = useMessagingContext();
  const [selectedConversationId, setSelectedConversationId] = useState<number | null>(null);
  const [messageText, setMessageText] = useState('');
  const [newChatUsername, setNewChatUsername] = useState('');
  const [isCreatingChat, setIsCreatingChat] = useState(false);
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [uploadingMedia, setUploadingMedia] = useState(false);
  const queryClient = useQueryClient();
  const [searchParams] = useSearchParams();
  const toUsernameParam = searchParams.get('to');
  const fileInputRef = useRef<HTMLInputElement>(null);

  const { data: conversations, isLoading: loadingConversations } = useQuery({
    queryKey: ['conversations'],
    queryFn: () => messagesService.getConversations(),
  });

  const { data: messages, isLoading: loadingMessages } = useQuery({
    queryKey: ['messages', selectedConversationId],
    queryFn: () => messagesService.getMessages(selectedConversationId!),
    enabled: !!selectedConversationId,
    refetchOnWindowFocus: false,
  });

  const uploadMediaMutation = useMutation({
    mutationFn: (file: File) => mediaService.uploadMedia(file),
  });

  const sendMessageMutation = useMutation({
    mutationFn: (data: SendMessageRequest) => messagesService.sendMessage(data),
    onSuccess: (message, variables) => {
      queryClient.invalidateQueries({ queryKey: ['messages', message.conversation_id] });
      queryClient.setQueryData<Conversation[] | undefined>(['conversations'], (prev) => {
        if (!prev) return prev;
        return prev.map((conv) =>
          conv.id === message.conversation_id
            ? {
                ...conv,
                unread_count: 0,
                latest_message: message,
              }
            : conv
        );
      });
      setMessageText('');
      setSelectedFile(null);
      if (!variables.conversation_id && variables.recipient_username) {
        setSelectedConversationId(message.conversation_id);
        setIsCreatingChat(false);
        setNewChatUsername('');
      }
    },
  });

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      if (file.size > MAX_UPLOAD_SIZE) {
        alert('File too large. Maximum size is 25MB.');
        return;
      }
      setSelectedFile(file);
    }
  };

  const handleSendMessage = async (e: React.FormEvent) => {
    e.preventDefault();
    const trimmedMessage = messageText.trim();
    if (!trimmedMessage && !selectedFile) return;

    try {
      let mediaFileId: number | undefined;
      let mediaUrl: string | undefined;
      let mediaMimeType: string | undefined;
      let mediaSize: number | undefined;
      let messageType: Message['message_type'] = 'text';

      // Upload media first if selected
      if (selectedFile) {
        setUploadingMedia(true);
        const uploadedMedia = await uploadMediaMutation.mutateAsync(selectedFile);
        mediaFileId = uploadedMedia.id;
        if (uploadedMedia.storage_url) {
          if (uploadedMedia.storage_url.startsWith('http')) {
            const urlObj = new URL(uploadedMedia.storage_url);
            mediaUrl = urlObj.pathname;
          } else {
            mediaUrl = uploadedMedia.storage_url.startsWith('/')
              ? uploadedMedia.storage_url
              : `/${uploadedMedia.storage_url}`;
          }
        } else if (uploadedMedia.storage_path) {
          const normalizedPath = uploadedMedia.storage_path.replace(/^\/?uploads\/?/, '');
          mediaUrl = `/uploads/${normalizedPath}`;
        }
        mediaMimeType = uploadedMedia.file_type;
        mediaSize = uploadedMedia.file_size;
        messageType = inferMessageTypeFromFile(selectedFile);
        setUploadingMedia(false);
      }

      if (isCreatingChat) {
        const recipient = newChatUsername.trim();
        if (!recipient) return;
        sendMessageMutation.mutate({
          recipient_username: recipient,
          content: trimmedMessage || undefined,
          media_file_id: mediaFileId,
          media_url: mediaUrl,
          media_type: mediaMimeType,
          media_size: mediaSize,
          message_type: messageType,
        });
        return;
      }

      if (selectedConversationId) {
        sendMessageMutation.mutate({
          conversation_id: selectedConversationId,
          content: trimmedMessage || undefined,
          media_file_id: mediaFileId,
          media_url: mediaUrl,
          media_type: mediaMimeType,
          media_size: mediaSize,
          message_type: messageType,
        });
      }
    } catch (error) {
      setUploadingMedia(false);
      console.error('Failed to send message:', error);
      alert('Failed to upload media. Please try again.');
    }
  };

  const selectedConversation = conversations?.find((c) => c.id === selectedConversationId);
  const orderedMessages = useMemo(() => (messages ? [...messages].reverse() : []), [messages]);
  const messagesContainerRef = useRef<HTMLDivElement | null>(null);
  const scrollToLatestMessage = useCallback(() => {
    const container = messagesContainerRef.current;
    if (container) {
      container.scrollTop = container.scrollHeight;
    }
  }, []);

  const markConversationAsRead = useCallback(
    async (conversationId: number) => {
      try {
        await messagesService.markAsRead(conversationId);
        queryClient.setQueryData<Conversation[] | undefined>(['conversations'], (prev) => {
          if (!prev) return prev;
          return prev.map((conv) =>
            conv.id === conversationId ? { ...conv, unread_count: 0 } : conv
          );
        });
        queryClient.invalidateQueries({ queryKey: ['conversations'] });
      } catch (error) {
        console.error('Failed to mark conversation as read', error);
      }
    },
    [queryClient]
  );

  // Sync selected conversation with global messaging context
  useEffect(() => {
    setActiveConversationId(selectedConversationId);
    return () => {
      setActiveConversationId(null);
    };
  }, [selectedConversationId, setActiveConversationId]);

  useEffect(() => {
    if (selectedConversationId && !isCreatingChat) {
      markConversationAsRead(selectedConversationId);
    }
  }, [selectedConversationId, isCreatingChat, markConversationAsRead]);

  useEffect(() => {
    if (toUsernameParam) {
      setIsCreatingChat(true);
      setSelectedConversationId(null);
      setNewChatUsername(toUsernameParam);
    }
  }, [toUsernameParam]);

  useEffect(() => {
    if (!selectedConversationId || isCreatingChat || loadingMessages) return;
    scrollToLatestMessage();
  }, [selectedConversationId, isCreatingChat, loadingMessages, scrollToLatestMessage, messages]);

  return (
    <div className="mx-auto flex h-[calc(100vh-8rem)] max-w-6xl gap-4 px-4 py-8">
      {/* Conversations List */}
      <div className="w-80 flex-shrink-0 overflow-hidden rounded-lg border border-[var(--color-border)] bg-[var(--color-surface)]">
        <div className="border-b border-[var(--color-border)] p-4">
          <div className="flex items-center justify-between">
            <h2 className="text-lg font-semibold text-[var(--color-text-primary)]">Messages</h2>
            <button
              onClick={() => {
                setIsCreatingChat(true);
                setSelectedConversationId(null);
                setNewChatUsername('');
                setMessageText('');
                setSelectedFile(null);
              }}
              className="rounded-md bg-[var(--color-primary)] px-3 py-1 text-sm font-semibold text-white hover:bg-[var(--color-primary-dark)]"
            >
              New Chat
            </button>
          </div>
        </div>

        <div className="overflow-y-auto" style={{ height: 'calc(100% - 65px)' }}>
          {loadingConversations && (
            <div className="p-4 text-center text-sm text-[var(--color-text-secondary)]">
              Loading...
            </div>
          )}

          {conversations?.map((conversation) => (
            <button
              key={conversation.id}
              onClick={() => {
                setSelectedConversationId(conversation.id);
                setIsCreatingChat(false);
                setNewChatUsername('');
                setSelectedFile(null);
              }}
              className={`w-full border-b border-[var(--color-border)] p-4 text-left transition-colors ${
                selectedConversationId === conversation.id
                  ? 'bg-[var(--color-surface-elevated)]'
                  : 'hover:bg-[var(--color-surface-elevated)]'
              }`}
            >
              <div className="flex items-center justify-between">
                <span className="font-medium text-[var(--color-text-primary)]">
                  {conversation.other_user?.username || 'Unknown'}
                </span>
                {conversation.unread_count > 0 && conversation.id !== selectedConversationId && (
                  <span className="rounded-full bg-[var(--color-primary)] px-2 py-0.5 text-xs text-white">
                    {conversation.unread_count}
                  </span>
                )}
              </div>
              {conversation.latest_message &&
                conversation.latest_message.encrypted_content &&
                !isAutoGeneratedMediaCaption(conversation.latest_message) && (
                  <p className="mt-1 truncate text-sm text-[var(--color-text-secondary)]">
                    {conversation.latest_message.encrypted_content}
                  </p>
                )}
            </button>
          ))}

          {conversations?.length === 0 && (
            <div className="p-4 text-center text-sm text-[var(--color-text-secondary)]">
              No conversations yet. Start a new chat!
            </div>
          )}
        </div>
      </div>

      {/* Chat Area */}
      <div className="flex flex-1 flex-col overflow-hidden rounded-lg border border-[var(--color-border)] bg-[var(--color-surface)]">
        {selectedConversationId || isCreatingChat ? (
          <>
            {/* Chat Header */}
            <div className="border-b border-[var(--color-border)] p-4">
              <h3 className="font-semibold text-[var(--color-text-primary)]">
                {isCreatingChat
                  ? 'New Chat'
                  : selectedConversation?.other_user?.username || 'Unknown'}
              </h3>
            </div>

            {/* Messages */}
            <div ref={messagesContainerRef} className="flex-1 overflow-y-auto p-4">
              {isCreatingChat ? (
                <div className="text-center text-sm text-[var(--color-text-secondary)]">
                  Enter a username and message to start a conversation
                </div>
              ) : loadingMessages ? (
                <div className="text-center text-sm text-[var(--color-text-secondary)]">
                  Loading messages...
                </div>
              ) : (
                <div className="space-y-3">
                  {orderedMessages.map((message) => (
                    <div
                      key={message.id}
                      className={`flex ${message.sender_id === user?.id ? 'justify-end' : 'justify-start'}`}
                    >
                      <div
                        className={`max-w-md rounded-lg px-4 py-2 ${
                          message.sender_id === user?.id
                            ? 'bg-[var(--color-primary)] text-white'
                            : 'bg-[var(--color-surface-elevated)] text-[var(--color-text-primary)]'
                        }`}
                      >
                        {message.media_url && (
                          <MessageMediaPreview message={message} />
                        )}
                        {message.encrypted_content && !isAutoGeneratedMediaCaption(message) && (
                          <p className="text-sm">{message.encrypted_content}</p>
                        )}
                        <span
                          className={`mt-1 block text-xs ${
                            message.sender_id === user?.id
                              ? 'text-white/70'
                              : 'text-[var(--color-text-muted)]'
                          }`}
                        >
                          {new Date(message.sent_at).toLocaleTimeString()}
                        </span>
                      </div>
                    </div>
                  ))}

                  {orderedMessages.length === 0 && (
                    <div className="text-center text-sm text-[var(--color-text-secondary)]">
                      No messages yet. Send the first message!
                    </div>
                  )}
                </div>
              )}
            </div>

            {/* Message Input */}
            <div className="border-t border-[var(--color-border)] p-4">
              {isCreatingChat && (
                <input
                  type="text"
                  value={newChatUsername}
                  onChange={(e) => setNewChatUsername(e.target.value)}
                  placeholder="Enter username..."
                  className="mb-2 block w-full rounded-md border border-[var(--color-border)] bg-[var(--color-surface-elevated)] px-3 py-2 text-sm text-[var(--color-text-primary)] placeholder-[var(--color-text-muted)] focus:border-[var(--color-primary)] focus:outline-none focus:ring-1 focus:ring-[var(--color-primary)]"
                />
              )}

              {selectedFile && (
                <div className="mb-2 flex items-center gap-2 rounded-md bg-[var(--color-surface-elevated)] p-2">
                  <span className="text-sm text-[var(--color-text-secondary)]">
                    {selectedFile.name}
                  </span>
                  <button
                    onClick={() => setSelectedFile(null)}
                    className="ml-auto text-sm text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)]"
                  >
                    âœ•
                  </button>
                </div>
              )}

              <form onSubmit={handleSendMessage} className="flex gap-2">
                <input
                  type="file"
                  ref={fileInputRef}
                  onChange={handleFileSelect}
                  className="hidden"
                />
                <button
                  type="button"
                  onClick={() => fileInputRef.current?.click()}
                  className="rounded-md border border-[var(--color-border)] bg-[var(--color-surface-elevated)] px-3 py-2 text-sm text-[var(--color-text-primary)] hover:bg-[var(--color-surface)]"
                  title="Attach file"
                >
                  ðŸ“Ž
                </button>
                <input
                  type="text"
                  value={messageText}
                  onChange={(e) => setMessageText(e.target.value)}
                  placeholder="Type a message..."
                  className="flex-1 rounded-md border border-[var(--color-border)] bg-[var(--color-surface-elevated)] px-3 py-2 text-sm text-[var(--color-text-primary)] placeholder-[var(--color-text-muted)] focus:border-[var(--color-primary)] focus:outline-none focus:ring-1 focus:ring-[var(--color-primary)]"
                />
                <button
                  type="submit"
                  disabled={
                    sendMessageMutation.isPending || uploadingMedia || (isCreatingChat && !newChatUsername.trim())
                  }
                  className="rounded-md bg-[var(--color-primary)] px-4 py-2 text-sm font-semibold text-white hover:bg-[var(--color-primary-dark)] disabled:opacity-50"
                >
                  {uploadingMedia ? 'Uploading...' : 'Send'}
                </button>
              </form>
            </div>
          </>
        ) : (
          <div className="flex flex-1 items-center justify-center text-[var(--color-text-secondary)]">
            Select a conversation or start a new chat
          </div>
        )}
      </div>
    </div>
  );
}
